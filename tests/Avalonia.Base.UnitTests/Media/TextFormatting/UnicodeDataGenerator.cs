using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text.RegularExpressions;
using Avalonia.Media.TextFormatting.Unicode;

namespace Avalonia.Base.UnitTests.Media.TextFormatting
{
    internal static class UnicodeDataGenerator
    {
        public const string Ucd = "https://www.unicode.org/Public/16.0.0/ucd/";

        public static UnicodeTrie GenerateBiDiTrie(out BiDiDataEntries biDiDataEntries, out Dictionary<int32, BiDiDataItem> biDiData)
        {
            biDiData = new Dictionary<int32, BiDiDataItem>();

            var bidiClassEntries =
                UnicodeEnumsGenerator.CreateBidiClassEnum();

            var bidiClassMappings = CreateTagToIndexMappings(bidiClassEntries);

            var bidiClassData = ReadBiDiData();

            foreach (var (range, name) in bidiClassData)
            {
                var biDiClass = bidiClassMappings[name];

                AddBiDiClassRange(biDiData, range, biDiClass);
            }

            var biDiPairedBracketTypeEntries = UnicodeEnumsGenerator.CreateBiDiPairedBracketTypeEnum();

            var biDiPairedBracketTypeMappings = CreateTagToIndexMappings(biDiPairedBracketTypeEntries);

            var biDiPairedBracketData = ReadBiDiPairedBracketData();
            
            foreach (var (range, name) in biDiPairedBracketData)
            {
                var bracketType = biDiPairedBracketTypeMappings[name];

                AddBiDiBracket(biDiData, range, bracketType);
            }
            
            var biDiTrieBuilder = new UnicodeTrieBuilder(/*initialValue*/);
            
            foreach (var properties in biDiData.Values)
            {
                //[bracket]|[bracketType]|[biDiClass]
                var value = (properties.BiDiClass << UnicodeData.BIDICLASS_SHIFT) |
                            (properties.BracketType << UnicodeData.BIDIPAIREDBRACKEDTYPE_SHIFT) | properties.Bracket;

                biDiTrieBuilder.Set(properties.Codepoint, (uint)value);
            }

            biDiDataEntries = new BiDiDataEntries()
            {
                PairedBracketTypes = biDiPairedBracketTypeEntries, BiDiClasses = bidiClassEntries
            };

            var trie = biDiTrieBuilder.Freeze();

            GenerateTrieClass("Bidi", trie);

            return trie;
        }

        public static void GenerateTrieClass(string name, UnicodeTrie trie)
        {
            using var fileStream = File.Create($"Generated\\{name}.trie.cs");
            using var writer = new StreamWriter(fileStream);

            writer.Write(
                $$"""
                  //---------------------------------------------------------------------------------------------------
                  // <auto-generated>
                  //     This code was generated by UnicodeDataGenerator.
                  //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
                  // </auto-generated>"
                  //---------------------------------------------------------------------------------------------------

                  using System;
                  using System.Runtime.CompilerServices;

                  namespace Avalonia.Media.TextFormatting.Unicode;

                  internal static class {{name}}Trie
                  {
                      public static UnicodeTrie Trie
                      {
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          get => new(Data, 0x{{trie.HighStart:X8}}, 0x{{trie.ErrorValue:X8}});
                      } 
                      
                      private static ReadOnlySpan<uint> Data => new uint[]
                      {
                  """);

            for (int32 i = 0; i < trie.Data.Length; ++i)
            {
                if (i > 0)
                    writer.Write(", ");

                if (i % 12 == 0)
                {
                    writer.WriteLine();
                    writer.Write("        ");
                }

                writer.Write("0x");
                writer.Write(trie.Data[i].ToString("X8"));
            }

            writer.Write(
                """
                
                    };
                }
                
                """);
        }

        public static UnicodeTrie GenerateUnicodeDataTrie(out UnicodeDataEntries dataEntries, out Dictionary<int32, UnicodeDataItem> unicodeData)
        {
            var generalCategoryEntries =
                UnicodeEnumsGenerator.CreateGeneralCategoryEnum();

            var generalCategoryMappings = CreateTagToIndexMappings(generalCategoryEntries);
            
            var scriptEntries = UnicodeEnumsGenerator.CreateScriptEnum();

            var scriptMappings = CreateNameToIndexMappings(scriptEntries);
            
            var lineBreakClassEntries =
                UnicodeEnumsGenerator.CreateLineBreakClassEnum();

            var lineBreakClassMappings = CreateTagToIndexMappings(lineBreakClassEntries);

            unicodeData = GetUnicodeData(generalCategoryMappings, scriptMappings, lineBreakClassMappings);
            
            var unicodeDataTrieBuilder = new UnicodeTrieBuilder(/*initialValue*/);
            
            foreach (var properties in unicodeData.Values)
            {
                //[line break]|[biDi]|[script]|[category]
                var value = (properties.LineBreakClass << UnicodeData.LINEBREAK_SHIFT) |
                            (properties.Script << UnicodeData.SCRIPT_SHIFT) | properties.GeneralCategory;

                unicodeDataTrieBuilder.Set(properties.Codepoint, (uint)value);
            }

            dataEntries = new UnicodeDataEntries
            {
                Scripts = scriptEntries,
                GeneralCategories = generalCategoryEntries,
                LineBreakClasses = lineBreakClassEntries
            };

            var trie = unicodeDataTrieBuilder.Freeze();

            GenerateTrieClass("UnicodeData", trie);

            return trie;
        }

        private static Dictionary<int32, UnicodeDataItem> GetUnicodeData(IReadOnlyDictionary<string, int32> generalCategoryMappings, 
            IReadOnlyDictionary<string, int32> scriptMappings, IReadOnlyDictionary<string, int32> lineBreakClassMappings)
        {
            var unicodeData = new Dictionary<int32, UnicodeDataItem>();
            
            var generalCategoryData = ReadGeneralCategoryData();

            foreach (var (range, name) in generalCategoryData)
            {
                var generalCategory = generalCategoryMappings[name];

                AddGeneralCategoryRange(unicodeData, range, generalCategory);
            }
            
            var scriptData = ReadScriptData();

            foreach (var (range, name) in scriptData)
            {
                var script = scriptMappings[name];

                AddScriptRange(unicodeData, range, script);
            }
            
            var lineBreakClassData = ReadLineBreakClassData();

            foreach (var (range, name) in lineBreakClassData)
            {
                var lineBreakClass = lineBreakClassMappings[name];

                AddLineBreakClassRange(unicodeData, range, lineBreakClass);
            }

            return unicodeData;
        }

        public static Dictionary<string, int32> CreateTagToIndexMappings(IReadOnlyList<DataEntry> entries)
        {
            var mappings = new Dictionary<string, int32>();

            for (var i = 0; i < entries.Count; i++)
            {
                mappings.Add(entries[i].Tag, i);
            }

            return mappings;
        }

        public static Dictionary<string, int32> CreateNameToIndexMappings(IReadOnlyList<DataEntry> entries)
        {
            var mappings = new Dictionary<string, int32>();

            for (var i = 0; i < entries.Count; i++)
            {
                mappings.Add(entries[i].Name, i);
            }

            return mappings;
        }

        private static void AddGeneralCategoryRange(Dictionary<int32, UnicodeDataItem> codepoints, CodepointRange range,
            int32 generalCategory)
        {
            for (var i = range.Start; i <= range.End; i++)
            {
                if (!codepoints.ContainsKey(i))
                {
                    codepoints.Add(i, new UnicodeDataItem { Codepoint = i, GeneralCategory = generalCategory });
                }
                else
                {
                    codepoints[i].GeneralCategory = generalCategory;
                }
            }
        }

        private static void AddScriptRange(Dictionary<int32, UnicodeDataItem> codepoints, CodepointRange range,
            int32 script)
        {
            for (var i = range.Start; i <= range.End; i++)
            {
                if (!codepoints.ContainsKey(i))
                {
                    codepoints.Add(i, new UnicodeDataItem { Codepoint = i, Script = script });
                }
                else
                {
                    codepoints[i].Script = script;
                }
            }
        }

        private static void AddBiDiClassRange(Dictionary<int32, BiDiDataItem> codepoints, CodepointRange range,
            int32 biDiClass)
        {
            for (var i = range.Start; i <= range.End; i++)
            {
                if (!codepoints.ContainsKey(i))
                {
                    codepoints.Add(i, new BiDiDataItem { Codepoint = i, BiDiClass = biDiClass });
                }
                else
                {
                    codepoints[i].BiDiClass = biDiClass;
                }
            }
        }

        private static void AddBiDiBracket(Dictionary<int32, BiDiDataItem> codepoints, CodepointRange range,
            int32 bracketType)
        {
            if (!codepoints.ContainsKey(range.Start))
            {
                codepoints.Add(range.Start,
                    new BiDiDataItem { Codepoint = range.Start, Bracket = range.End, BracketType = bracketType });
            }
            else
            {
                var codepoint = codepoints[range.Start];

                codepoint.Bracket = range.End;
                codepoint.BracketType = bracketType;
            }
        }

        private static void AddLineBreakClassRange(Dictionary<int32, UnicodeDataItem> codepoints, CodepointRange range,
            int32 lineBreakClass)
        {
            for (var i = range.Start; i <= range.End; i++)
            {
                if (!codepoints.ContainsKey(i))
                {
                    codepoints.Add(i, new UnicodeDataItem { Codepoint = i, LineBreakClass = lineBreakClass });
                }
                else
                {
                    codepoints[i].LineBreakClass = lineBreakClass;
                }
            }
        }

        public static List<(CodepointRange, string)> ReadGeneralCategoryData()
        {
            return ReadUnicodeData("extracted/DerivedGeneralCategory.txt");
        }

        public static List<(CodepointRange, string)> ReadScriptData()
        {
            return ReadUnicodeData("Scripts.txt");
        }

        public static List<(CodepointRange, string)> ReadBiDiData()
        {
            return ReadUnicodeData("extracted/DerivedBidiClass.txt");
        }

        public static List<(CodepointRange, string)> ReadLineBreakClassData()
        {
            return ReadUnicodeData("extracted/DerivedLineBreak.txt");
        }
        
        public static List<(CodepointRange, string)> ReadBiDiPairedBracketData()
        {
            const string file = "BidiBrackets.txt";
        
            var data = new List<(CodepointRange, string)>();
            
            var regex = new Regex(@"^([0-9A-F]+);\s([0-9A-F]+);\s([ocn])");

            using (var client = new HttpClient())
            {
                var url = Path.Combine(Ucd, file);

                using (var result = client.GetAsync(url).GetAwaiter().GetResult())
                {
                    if (!result.IsSuccessStatusCode)
                    {
                        return data;
                    }

                    using (var stream = result.Content.ReadAsStreamAsync().GetAwaiter().GetResult())
                    using (var reader = new StreamReader(stream))
                    {
                        while (!reader.EndOfStream)
                        {
                            var line = reader.ReadLine();

                            if (string.IsNullOrEmpty(line))
                            {
                                continue;
                            }

                            var match = regex.Match(line);

                            if (!match.Success)
                            {
                                continue;
                            }

                            var start = Convert.ToInt32(match.Groups[1].Value, 16);

                            var end = start;

                            if (!string.IsNullOrEmpty(match.Groups[2].Value))
                            {
                                end = Convert.ToInt32(match.Groups[2].Value, 16);
                            }

                            data.Add((new CodepointRange(start, end), match.Groups[3].Value));
                        }
                    }
                }
            }

            return data;
        }

        private static List<(CodepointRange, string)> ReadUnicodeData(string file)
        {
            var data = new List<(CodepointRange, string)>();

            var regex = new Regex(@"([0-9A-F]+)(?:\.\.([0-9A-F]+))?\s+;\s+(\w+)\s+#.*", RegexOptions.Compiled);

            using (var client = new HttpClient())
            {
                var url = Path.Combine(Ucd, file);

                using (var result = client.GetAsync(url).GetAwaiter().GetResult())
                {
                    if (!result.IsSuccessStatusCode)
                    {
                        return data;
                    }

                    using (var stream = result.Content.ReadAsStreamAsync().GetAwaiter().GetResult())
                    using (var reader = new StreamReader(stream))
                    {
                        while (!reader.EndOfStream)
                        {
                            var line = reader.ReadLine();

                            if (string.IsNullOrEmpty(line))
                            {
                                continue;
                            }

                            var match = regex.Match(line);

                            if (!match.Success)
                            {
                                continue;
                            }

                            var start = Convert.ToInt32(match.Groups[1].Value, 16);

                            var end = start;

                            if (!string.IsNullOrEmpty(match.Groups[2].Value))
                            {
                                end = Convert.ToInt32(match.Groups[2].Value, 16);
                            }

                            data.Add((new CodepointRange(start, end), match.Groups[3].Value));
                        }
                    }
                }
            }

            return data;
        }

        internal class UnicodeDataItem
        {
            public int32 Codepoint { get; set; }

            public int32 Script { get; set; }

            public int32 GeneralCategory { get; set; }

            public int32 BiDiClass { get; set; }

            public int32 LineBreakClass { get; set; }
        }
        
        internal class BiDiDataItem
        {
            public int32 Codepoint { get; set; }

            public int32 Bracket { get; set; }

            public int32 BracketType { get; set; }

            public int32 BiDiClass { get; set; }
        }      
    }
    
    internal class UnicodeDataEntries
    {
        public IReadOnlyList<DataEntry> Scripts { get; set; }
        public IReadOnlyList<DataEntry> GeneralCategories{ get; set; }
        public IReadOnlyList<DataEntry> LineBreakClasses{ get; set; }
    }
    
    internal class BiDiDataEntries
    {
        public IReadOnlyList<DataEntry> PairedBracketTypes { get; set; }
        public IReadOnlyList<DataEntry> BiDiClasses{ get; set; }
    }

    internal readonly struct CodepointRange
    {
        public CodepointRange(int32 start, int32 end)
        {
            Start = start;
            End = end;
        }

        public int32 Start { get; }
        public int32 End { get; }
    }
}
